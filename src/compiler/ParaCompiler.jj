/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false;
  LOOKAHEAD = 1;
}

PARSER_BEGIN(ParaCompiler)
package compiler;

import java.util.HashMap;
import java.io.*;
import compiler.ast.*;


public class ParaCompiler {


  // <<< TABELA DE SÍMBOLOS >>>
  private HashMap<String, String> symbolTable = new HashMap<>();

  private void declareVariable(String nome, String tipo) throws ParseException {
      if (symbolTable.containsKey(nome)) {
          throw new ParseException("Variável '" + nome + "' já foi declarada!");
      }
      symbolTable.put(nome, tipo);
  }

  private void checkVariable(String nome) throws ParseException {
      if (!symbolTable.containsKey(nome)) {
          throw new ParseException("Variável '" + nome + "' NÃO foi declarada!");
      }
 }
  
  public static void main(String args[]) throws ParseException, IOException {
    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    String linha;

    System.out.println("=== Linguagem de programacao paraense COP30! ===");
    System.out.println("Digite seu programa:");

    ParaCompiler parser = new ParaCompiler(System.in); 

    while (true) {
      linha = reader.readLine();

      if (linha == null || linha.trim().isEmpty()) {
        System.out.println("Compilador encerrado.");
        break;
      }

      parser.ReInit(new ByteArrayInputStream(linha.getBytes()));

      try {
        Program prog = parser.program();
        System.out.println("Análise concluída!");
        System.out.println(prog.toString());
      } catch (Exception e) {
        System.out.println("TU É LESO! Gala Seca!! Erro de sintaxe!");
        System.out.println(e.getMessage());
      } catch (Error e) {
        System.out.println("CAVALO MORDEU TUA CABEÇA, LESO? Erro léxico!");
        System.out.println(e.getMessage());
      }

      System.out.println("\nDigite outro programa:");
    }
  }
}



PARSER_END(ParaCompiler)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\u00A0" // <--- ADICIONE ESTA LINHA
}

TOKEN :
{
  < INICIOPROG   : "ohjata"     >
| < ABREBLOCO    : "<"          >
| < FECHABLOCO   : ">"          >
| < FIMINSTRUC   : "."          >

| < INICIAVAR    : "disk"       >
| < FOR          : "dalhe"      >
| < WHILE        : "caquiado"   >
| < IF           : "emesmo"     >
| < ELSE         : "masquando"  >
| < ATRIBUICAO   : "->"         >

| < TIPOCHAR     : "egua"       >
| < TIPOINT      : "intera"     > 
| < TIPOFLOAT    : "meroubalogo">
  
| < OPMAIOR      : ">>"         >
| < OPMENOR      : "<<"         >
| < OPDIF        : "!="         >
| < OPIGUAL      : "=="         >
| < OPINC        : "++"         >
| < OPDEC        : "--"         >

| < ABREPARENT   : "{"          >
| < FECHAPARENT  : "}"          >
| < VIRGULA      : ","          >

| < PLUS         : "+"          >
| < MINUS        : "-"          >
| < TIMES        : "*"          >
| < DIVIDE       : "/"          >



| < IDENT        : ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z", "0"-"9"])* >
| < NUM          : (< DIGITO >)+ ( "." (< DIGITO >)+ )? >
| < STRING_LITERAL : "\"" (~["\""])* "\"" >

| < #DIGITO      : [ "0"-"9" ] >
}

Program program() :
{
    Program prog = new Program();
    Statement stmt;
}
{
	< INICIOPROG > < ABREBLOCO > ( stmt = statement() { prog.addStatement(stmt); } )* < FECHABLOCO > <EOF>
	{ return prog; }
}

Statement statement() :
{
    Statement stmt;
    Expression expr;
}
{
    (
      stmt = declaracao()
    | stmt = ifStatement()
    | stmt = whileStatement()
    | stmt = forStatement()
    | expr = expression()
      (
        <ATRIBUICAO>
        {
            if (!(expr instanceof Identifier)) {
                throw new ParseException("Left side of assignment must be an identifier.");
            }
        }
        {
             Expression right = expression();
             stmt = new Assignment(((Identifier)expr).getName(), right);
        }
      |
        { stmt = expr; }
      )
    )
    <FIMINSTRUC>
    { return stmt; }
}

Declaration declaracao() :
{
    String type;
    Declaration decl;
}
{
    < INICIAVAR > type = tipoDado() { decl = new Declaration(type); } listaIdentificadores(decl)
    { return decl; }
}

String tipoDado() :
{
    Token t;
}
{
    ( t = < TIPOCHAR > | t = < TIPOFLOAT > | t = < TIPOINT > )
    { return t.image; }
}

void listaIdentificadores(Declaration decl) :
{
  Token id;
  Expression expr = null;
}
{
    id = <IDENT>
      {
        declareVariable(id.image, "VAR");
      }
    ( <ATRIBUICAO> expr = expression() )?
    { decl.addVariable(id.image, expr); expr = null; }
    ( <VIRGULA>
        id = <IDENT>
        {
          declareVariable(id.image, "VAR");
        }
        ( <ATRIBUICAO> expr = expression() )?
        { decl.addVariable(id.image, expr); expr = null; }
    )*
}


Expression expression() :
{
  Expression left;
  Expression right;
  Token op;
}
{
  left = term() ( ( op = < PLUS > | op = < MINUS > ) right = term() { left = new BinaryExpression(left, op.image, right); } )*
  { return left; }
}

Expression term() :
{
  Expression left;
  Expression right;
  Token op;
}
{
  left = factor() ( ( op = < TIMES > | op = < DIVIDE > ) right = factor() { left = new BinaryExpression(left, op.image, right); } )*
  { return left; }
}

Expression factor() :
{
  Token t;
  Expression expr;
}
{
    t = <NUM> { return new Literal(t.image, "NUM"); }
  | t = <IDENT> { checkVariable(t.image); return new Identifier(t.image); }
  | t = <STRING_LITERAL> { return new Literal(t.image, "STRING"); }
  | ( <ABREPARENT> expr = expression() <FECHAPARENT> { return expr; } )
}

String opLog() :
{
    Token t;
}
{
  ( t = < OPMAIOR >  | t = < OPMENOR > | t = < OPDIF > | t = < OPIGUAL > )
  { return t.image; }
}


Expression expLogica() :
{
    Expression left;
    Expression right;
    String op;
}
{
  left = expression() op = opLog() right = expression()
  { return new BinaryExpression(left, op, right); }
}


IfStatement ifStatement() :
{
    Expression cond;
    Block thenBlock = new Block();
    Block elseBlock = null;
    Statement stmt;
}
{
    < IF > < ABREPARENT > cond = expLogica() < FECHAPARENT >
    < ABREBLOCO > (stmt = statement() { thenBlock.addStatement(stmt); })* < FECHABLOCO >
    ( < ELSE > < ABREBLOCO > { elseBlock = new Block(); } (stmt = statement() { elseBlock.addStatement(stmt); })* < FECHABLOCO > )?
    { return new IfStatement(cond, thenBlock, elseBlock); }
}

WhileStatement whileStatement() :
{
    Expression cond;
    Block body = new Block();
    Statement stmt;
}
{
    < WHILE > < ABREPARENT > cond = expLogica() < FECHAPARENT >
    < ABREBLOCO > (stmt = statement() { body.addStatement(stmt); })* < FECHABLOCO >
    { return new WhileStatement(cond, body); }
}


Assignment forIncremento() :
{
    Token id;
    Expression expr;
}
{
    id = < IDENT > < ATRIBUICAO > expr = expression()
    { return new Assignment(id.image, expr); }
}

ForStatement forStatement() :
{
    Declaration init;
    Expression cond;
    Statement inc;
    Block body = new Block();
    Statement stmt;
}
{
    < FOR > < ABREPARENT > init = declaracao() cond = expLogica() < FIMINSTRUC > inc = forIncremento() < FECHAPARENT >
    < ABREBLOCO > (stmt = statement() { body.addStatement(stmt); })* < FECHABLOCO >
    { return new ForStatement(init, cond, inc, body); }
}